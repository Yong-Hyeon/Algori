# Algori

## 목차
-[백준 12865 평범한 배낭](#백준-12865-평범한-배낭)

---

## 백준 12865 평범한 배낭
### 사용 알고리즘 : DP
#### 가장 기본적인 배낭문제를 풀기 위해서 부분집합을 이용해 물건을 선택해서 배낭에 집어넣고 무게제한과 최대 가치를 구할 수 있지만 이 문제의 물건 개수는 100개여서 부분집합으로 풀게되면 2^100의 시간복잡도가 걸려서 시간초과가 되기 때문에 DP로 풀어야함.
- 제약조건
  - 최대 가치가 100,000이고 메모리 제한이 256MB여서 1차원 배열 100,000개 만들어도 괜찮음.
  - 최대 배열 100,000개에 최대 물건 개수 100개여서 반복횟수 100,000 * 100 해도 10,000,000 대략 0.1초여서 시간복잡도도 괜찮음.
- 문제풀이
  - 물건의 개수 N, 최대 무게 K를 입력받는다.
  - N번 반복하며 물건의 무게 W, 가치 V를 각각 배열을 만들어서 입력받는다.
  - 배낭에 물건을 담는 것을 표현할 K만큼의 배열을 만들어서 가방에 물건을 집어넣는 것을 Mamoization 하는 느낌으로 사용.
  - 물건의 개수만큼 반복하면서 배낭에 물건을 담으려 할 때 물건을 담는게 그 무게에서 만들 수 있는 최대 가치를 업데이트해줌
    - 배낭에 물건을 담으면 그 무게만큼 추가되니까 "무게를 더한 부분의 배낭에 원래 저장된 값"과 "무게를 추가하기 전의 무게 부분의 가치에서 물건의 가치를 더한 가치"를 비교
    - 비교할 배낭의 무게가 10, 담으려 하는 물건의 무게가 5면 배낭[10]의 위치의 값과 배낭[5(10-5)] + 물건의 가치와 비교를 해서 최대값을 배낭[10]에 저장
    - 위의 과정을 물건을 담을 수 있는 모든 무게에서 실행 -> 배낭에 모든 무게(인덱스)마다 담을 수 있는 최대 가치가 저장되게됨.
    - 배열의 앞 인덱스부터 하면 계속 비교하면서 바뀐 값을 비교하게 될 수 있으니 뒤 인덱스(최대무게부분)부터 실행!
  - 마지막으로 배열의 K번째 인덱스 즉 가방에 담을 수 있는 최대 무게 부분에 저장된 값을 출력하면 그게 답이 됨!
